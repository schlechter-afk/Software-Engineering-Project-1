{
    "base": "You are a senior software engineer who is trying to refactor a project. \nDo not reply with ANYTHING besides the source code in the new language.\nMake SURE the syntax is correct, and the new code matches the functionality of the source code exactly.\n\nWrite the code in a modern, functional, clean manner. Do NOT include any markdown syntax.\nDo NOT include any explanations, or any other text besides the source code.\nIf you refactor anything, add a comment explaining the changes made.\nIf a specific feature does not exist in the target language, don't include it and include a comment explaining why.\nIf you are not sure how to refactor a specific part, just leave it as is.\n\n",
    "code_desc": "The file I want you to refactor is {file_name}.\nHere's the code\n",
    "checkstyle_desc": "For the above code, we detected the following code metrics using a tool called CheckStyle.\nTreat them as code smells:\n\n",
    "checkstyle_metrics": "The description of the metrics given above are:\n - BooleanExpressionComplexity: Restricts the number of boolean operators (&&, ||, &, | and ^) in an expression. Rationale: Too many conditions leads to code that is difficult to read and hence debug and maintain. \n - ClassDataAbstractionCoupling: Measures the number of instantiations of other classes within the given class or record. This type of coupling is not caused by inheritance or the object-oriented paradigm. Generally speaking, any data type with other data types as members or local variable that is an instantiation (object) of another class has data abstraction coupling (DAC). The higher the DAC, the more complex the structure of the class. \n - ClassFanOutComplexity: Checks the number of other types a given class/record/interface/enum/annotation relies on. Also, the square of this has been shown to indicate the amount of maintenance required in functional programs (on a file basis) at least.\n - CyclomaticComplexity: Checks cyclomatic complexity against a specified limit. It is a measure of the minimum number of possible paths through the source and therefore the number of required tests, it is not about quality of code! It is only applied to methods, c-tors, static initializers and instance initializers. The complexity is equal to the number of decision points + 1. Decision points: if, while , do, for, ?:, catch , switch, case statements and operators && and || in the body of target. \n - JavaNCSS: Roughly said the NCSS metric is calculated by counting the source lines which are not comments, (nearly) equivalent to counting the semicolons and opening curly braces. Rationale: Too large methods and classes are hard to read and costly to maintain. A large NCSS number often means that a method or class has too many responsibilities and/or functionalities which should be decomposed into smaller units. \n - NPathComplexity: The NPATH metric computes the number of possible execution paths through a function(method). It takes into account the nesting of conditional statements and multipart boolean expressions (A && B, C || D, E ? F :G and their combinations). \n\n",                    
    "prompt_ending": "Think carefully and remember that you are a seasoned software engineer experienced in refactoring codebases. Only return me the refactored code block.\n\n"
}
